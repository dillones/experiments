<html>
<head>
  <title>âˆ‡</title>
  <meta name="viewport" content="width=360, initial-scale=1.0, maximum-scale=1.0">
  <!-- <link href="https://fonts.googleapis.com/icon?family=Material+Icons"rel="stylesheet"> -->
  <link href="https://fonts.googleapis.com/css?family=Lekton" rel="stylesheet">
  <style>
    body {
      background: #000;
      margin: 0;
      color: #fff;
      font-size: 48px;
      overflow: hidden;
    }
  </style>
</head>
<!-- <body oncontextmenu="return false;"> -->
<body>

<script src="https://ajax.googleapis.com/ajax/libs/threejs/r84/three.min.js"></script>
<!-- <script src="js/three.min.r84.js"></script> -->
<script>

window.onload = init;
window.onresize = resize;

const ui = new Ui();
var renderer, scene, camera, mesh;

var rotatex = { id: 'Rotation X', value: 10, lo: 0, hi: 99 };
var rotatey = { id: 'Rotation Y', value: 10, lo: 0, hi: 99 };
var rotatez = { id: 'Rotation Z', value: 10, lo: 0, hi: 99 };

var rotation = 0;

function init(){

  renderer = new THREE.WebGLRenderer();
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.setPixelRatio(1);

  renderer.domElement.id = 'renderer';
  document.body.appendChild(renderer.domElement);
  renderer.domElement.style.position = 'fixed';
  renderer.domElement.style.zIndex = 0;

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight);

  const light    = new THREE.HemisphereLight(0xffece0, 0xe6546e);
  const geometry = new THREE.IcosahedronGeometry(2,2);
  const material = new THREE.MeshPhongMaterial({ color: 0xffffff, shading: THREE.FlatShading, side: THREE.BackSide });

  mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
  scene.add(light);

  ui.connect();
  console.log('Initialized');

  main();
}

function resize(){
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();

  ui.disconnect();
  ui.connect();
}

function main(){
  window.requestAnimationFrame(main);
  renderer.render(scene, camera);

  mesh.rotateX(rotatex.value * 0.00005);
  mesh.rotateY(rotatey.value * 0.00005);
  mesh.rotateZ(rotatez.value * 0.00005);

  ui.update();
}

function Ui(){

  const scope = this;
  this.canvas;
  this.ctx;
  this.font;
  this.update;

  this.touch = new THREE.Vector2();
  var TOUCH = false;

  var timer, framerate;
  var time, now, last, fps;
  var range = [];

  var u = 20;
  var row  = [];
  var col  = [];

  var rows, cols;
  var w, h;

  this.requestUpdates = [];

  this.connect = function(){

    w = 360;
    h = window.innerHeight;

    var fill = '#111111';

    this.canvas = document.createElement('canvas');
    this.canvas.id = 'ui';
    this.canvas.width = w;
    this.canvas.height = window.innerHeight;
    this.canvas.style.position = 'fixed';
    this.canvas.style.zIndex = '100';
    document.body.appendChild(this.canvas);

    this.ctx = this.canvas.getContext('2d');
    this.ctx.font = '13px Lekton';
    this.ctx.fillStyle = fill;
    this.ctx.textBaseline = 'top';

    cols = Math.floor(window.innerWidth/u);
    rows = Math.floor(window.innerHeight/u);

    for ( var i = 0; i < cols; i++ ){
      col[i] = i * u;
    }

    for ( var i = 0; i < rows; i++ ){
      row[i] = i * u;
    }

    this.make();

    this.update = this.main;

    window.addEventListener( 'touchstart', this.touchstart);
    window.addEventListener( 'touchmove' , this.touchmove);
    window.addEventListener( 'touchend'  , this.touchend );

    window.addEventListener( 'mousedown', this.touchstart );
    window.addEventListener( 'mousemove', this.touchmove );
    window.addEventListener( 'mouseup'  , this.touchend );

    console.log('Ui Connected');
  }

  this.make = function(){
    const title = new this.Label('Three User Interface Experiment - ', col[1], row[2], w/2-u, u, 'left');

    range[0] = new this.Range( rotatex, col[1], row[6], w-u*2, 1 );
    this.requestUpdates.push( range[0] );

    range[1] = new this.Range( rotatey, col[1], row[9], w-u*2, 1 );
    this.requestUpdates.push( range[1] );

    range[2] = new this.Range( rotatez, col[1], row[12], w-u*2, 1 );
    this.requestUpdates.push( range[2] );

    time = window.performance.now();
    last = window.performance.now();
  }

  this.disconnect = function(){

    document.body.removeChild(this.canvas);
    this.canvas = null;
    this.ctx = null;
    this.font = null;
    this.update = function(){};
    this.requestUpdates = [];

    window.removeEventListener( 'touchstart', this.touchstart);
    window.removeEventListener( 'touchmove' , this.touchmove);
    window.removeEventListener( 'touchend'  , this.touchend );

    window.removeEventListener( 'mousedown', this.touchstart );
    window.removeEventListener( 'mousemove', this.touchmove );
    window.removeEventListener( 'mouseup'  , this.touchend );

  }

  this.main = function(){

      if( TOUCH ){
        for ( var i in this.requestUpdates ){
          this.requestUpdates[i].update();
        }
      }

  }

  // Label Object
  this.Label = function( text, x, y, w, h, align ){

      scope.ctx.textAlign = align;
      scope.ctx.beginPath();
      scope.ctx.fillText( text, x, y );
      scope.ctx.closePath();

    this.update = function(value){
      scope.ctx.textAlign = align;
      scope.ctx.beginPath();
      scope.ctx.clearRect(x,y,w,h);
      scope.ctx.fillText( value, x, y );
      scope.ctx.closePath();
      text = value;
    }
  }

  // Range Object
  this.Range = function(target, x, y, w, h ){

    console.log(target.value);

    const label  = new scope.Label(target.id, x, y-u*2, w, u, 'left');
    var output   = new scope.Label(target.value, w+u, y-u*2, -w/2, u, 'right' );

      y = y+h/2;

      this.position = new THREE.Vector2(x+target.value-u/4, y-u/4);

      scope.ctx.beginPath();
      scope.ctx.fillRect(x, y, w, h);
      scope.ctx.fillRect(this.position.x, this.position.y, u/2+1, u/2+1);
      scope.ctx.closePath();

      console.log(target, 'Connected');


    this.update = function(){

      const c0 = ( scope.touch.x >= x+u/4 && scope.touch.x <= w+u-u/4 );
      const c1 = ( scope.touch.distanceTo(this.position) < u*2 );
      const c2 = ( Math.abs(scope.touch.y-this.position.y) < u * 2 );

      if( c0 && ( c1 || c2 ) ){

        this.position.x = scope.touch.x-u/4;
        scope.ctx.beginPath();
        scope.ctx.clearRect(x-1, y-u/4-1,w+u+1,u+2);
        scope.ctx.fillRect(x, y, w, h);
        scope.ctx.fillRect(this.position.x, this.position.y, u/2+1, u/2+1);
        scope.ctx.closePath();

        target.value = this.position.x;
        output.update(target.value);

      }
    }


}

  this.touchstart = function(event){
    TOUCH = true;
      switch(event.type){
        case( 'mousedown'):
          scope.touch.set( event.clientX, event.clientY );
        break;
        case( 'touchstart'):
          scope.touch.set( event.touches[0].clientX, event.touches[0].clientY );
      break;
    }
  }

  this.touchmove = function(event){
    switch(event.type){
      case( 'mousemove'):
        scope.touch.set( event.clientX, event.clientY );
      break;
      case( 'touchmove'):
        scope.touch.set( event.touches[0].clientX, event.touches[0].clientY );
      break;
    }
  }

  this.touchend = function(event){
    TOUCH = false;
  }

  this.requestLog = function(event){
    console.log(event.type);
    console.log(event);
  }

}

</script>
</body>
</html>
